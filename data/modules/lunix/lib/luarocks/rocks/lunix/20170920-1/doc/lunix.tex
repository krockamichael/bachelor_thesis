%:
\documentclass[11pt, oneside]{memoir}

\usepackage{fullpage}
\usepackage{xspace}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}

\setlength{\parindent}{0pt}
\nonzeroparskip

% add padding to ctabular tables
\renewcommand{\arraystretch}{1.2}

\makeindex

%
% COMMANDS
%
\newcommand*{\lunix}[0]{\texttt{lunix}\xspace}
\newcommand*{\luaposix}[0]{\texttt{luaposix}\xspace}
\newcommand*{\cqueues}[0]{\texttt{cqueues}\xspace}
\newcommand*{\true}[0]{\texttt{true}\xspace}
\newcommand*{\false}[0]{\texttt{false}\xspace}
\newcommand*{\nil}[0]{\texttt{nil}\xspace}
\newcommand*{\key}[1]{#1\index{#1}\xspace}
\newcommand*{\syscall}[1]{\texttt{#1}\xspace}
\newcommand*{\routine}[1]{\texttt{#1}\xspace}
\newcommand*{\fn}[1]{\texttt{#1}\xspace}
\newcommand*{\const}[1]{\texttt{#1}\xspace}
\newcommand*{\method}[1]{\texttt{#1}\xspace}
\newcommand*{\module}[1]{\texttt{#1}\xspace}
\newcommand*{\errno}[1]{\texttt{#1}\xspace}
\newcommand*{\crlf}[0]{$\backslash$r$\backslash$n\xspace}
\newcommand*{\lf}[0]{$\backslash$n\xspace}
\newcommand*{\otherwise}[1]{otherwise #1, an error string, and an integer system error}
\newcommand*{\sockaddr}[0]{\texttt{sockaddr}\xspace}
\newcommand*{\mustbe}[0]{\texttt{must be}\xspace}
\newcommand*{\seefn}[1]{\hyperref[#1]{\fn{#1}}\xspace}

%
% ENVIRONMENTS
%
\lstdefinelanguage{lua}{
morekeywords={break,goto,do,end,while,repeat,until,if,then,elseif,else,for,in,function,local,nil,false,true,and,or,not},
sensitive=true,
morestring=[b]"
}

\lstnewenvironment{code}[1]{
	\lstset{language=#1}
}{
}

\lstnewenvironment{example}[1]{
	\lstset{language=#1,numbers=left,numberstyle=\tiny,stepnumber=2,tabsize=4}
	\ttfamily\small
}{
}

\newcounter{toccols}
\setcounter{toccols}{2}
\newenvironment{Module}[1]{
	\subsection{\texttt{#1}}
	\addtocontents{toc}{
		\protect\begin{multicols}{\value{toccols}}
		%\renewcommand*{\cftsubsubsectiondotsep}{\cftnodots}%
	}
}{
	\addtocontents{toc}{\protect\end{multicols}}
}


\lstdefinelanguage{lua}{morekeywords={break,goto,do,end,while,repeat,until,if,then,elseif,else,for,in,function,local,nil,false,true,and,or,not},sensitive=true,morestring=[b]"}


\begin{document}

%\pagestyle{empty}

\title{

\vspace*{10ex}

\HUGE\sffamily User Guide to \lunix, \\

%\vspace*{20pt}
%\hrule

\HUGE Comprehensive Unix API Module for Lua \\

\vspace*{30pt}
\hrule
}

\date{\today}
\author{William Ahern}
%\setlength{\droptitle}{85pt}
\maketitle
\thispagestyle{empty}
\clearpage

\maxtocdepth{subsubsection}
\setsecnumdepth{subsection}
\setcounter{page}{1}
\pagenumbering{roman}
\tableofcontents

\clearpage

\setcounter{page}{1}
\pagenumbering{arabic}

\chapterstyle{section}
\setlength{\beforechapskip}{1ex}
\setlength{\afterchapskip}{1ex}

\chapter{About}

\lunix is a bindings library module to common Unix system APIs. The module is regularly tested with Linux/glibc, Linux/musl, OS X, FreeBSD, NetBSD, OpenBSD, Solaris, and AIX. The best way to describe it is in contradistinction to \luaposix, the most popular bindings module for Unix APIs in Lua.

\paragraph{Thread-safety}

Unlike \luaposix, it strives to be as thread-safe as possible on the host platform. Interfaces like \fn{strerror\_r} and \const{O\_CLOEXEC} are used throughout. The module even includes a novel solution for the inherently non-thread-safe \fn{umask} system call, where calling \fn{umask} from one thread might result in another thread creating a file with unsafe or unexpected permissions.

\paragraph{POSIX Extensions}

Unlike \luaposix, the library does not restrict itself to POSIX, and emulates an interface when not available natively on a supported platform. For example, the library provides \fn{arc4random} (absent on Linux and Solaris), \fn{clock\_gettime} (absent on OS X), and a thread-safe \fn{timegm} (absent on Solaris).

\paragraph{Leak-safety}

Unlike \luaposix, the library prefers dealing with \const{FILE} handles rather than raw integer descriptors. This helps to mitigate and prevent leaks or double-close bugs---a common source of problems in, e.g., asynchronous applications. Routines like \fn{chdir}, \fn{stat}, and \fn{opendir} transparently accept string paths, FILE handles, DIR handles, and raw integer descriptors.

\chapter{Dependencies}

\section{Operating Systems}

\lunix targets modern POSIX-conformant and POSIX-aspiring systems. But unlike \texttt{luaposix} it branches out to implement common GNU and BSD extensions. All interfaces are available on all supported platforms, regardless of whether the platform provides a native interface.

I try to regularly compile and test the module against recent versions of OS X, Linux/glibc, Linux/musl, FreeBSD, NetBSD, OpenBSD, Solaris, and AIX.

\section{Libraries}

\subsection{Lua 5.1, 5.2, 5.3}

\lunix targets Lua 5.1 and above.

\section{GNU Make}

The Makefile requires GNU Make, usually installed as gmake on platforms other than Linux or OS X. The actual \texttt{Makefile} proxies to \texttt{GNUmakefile}. As long as \texttt{gmake} is installed on non-GNU systems you can invoke your system's \texttt{make}.

\chapter{Installation}

The module is composed of a single C source file to simplify compilation across environments. Because there several extant versions of Lua often used in parallel on the same system, there are individual targets to build and install the module for each supported Lua version. The targets \texttt{all} and \texttt{install} will attempt to build and install both Lua 5.1 and 5.2 modules.

Note that building and installation and can accomplished in a single step by simply invoking one of the install targets with all the necessary variables defined.

\section{Building}

There is no separate \texttt{./configure} step required.\footnote{Optional autoconf configuration is currently being tested. Run \texttt{./bootstrap} to build the \texttt{./configure} script} System introspection and feature detection occurs during compile-time. The ``\texttt{configure}'' make target can be used to cache the build environment so one needn't continually use a long command-line invocation.

All the common GNU-style compiler variables are supported, including \texttt{CC}, \texttt{CPPFLAGS}, \texttt{CFLAGS}, \texttt{LDFLAGS}, and \texttt{SOFLAGS}. Note that you can specify the path to Lua 5.1, Lua 5.2, and Lua 5.3 include headers at the same time in CPPFLAGS; the build system will work things out to ensure the correct headers are loaded when compiling each version of the module.

\subsection{Targets}

\begin{description}
\item[\texttt{all}] \hfill \\
Build modules for Lua 5.1 and 5.2.

\item[\texttt{all5.1}] \hfill \\
Build Lua 5.1 module.

\item[\texttt{all5.2}] \hfill \\
Build Lua 5.2 module.

\item[\texttt{all5.3}] \hfill \\
Build Lua 5.3 module.

\end{description}

\section{Installing}

All the common GNU-style installation path variables are supported, including \texttt{prefix}, \texttt{bindir}, \texttt{libdir}, \texttt{datadir}, \texttt{includedir}, and \texttt{DESTDIR}. These additional path variables are also allowed:

\begin{description}

\item[\texttt{lua51path}]  \hfill \\
Install path for Lua 5.1 modules, e.g. \texttt{\$(prefix)/share/lua/5.1}

\item[\texttt{lua51cpath}]  \hfill \\
Install path for Lua 5.1 C modules, e.g. \texttt{\$(prefix)/lib/lua/5.1}

\item[\texttt{lua52path}]  \hfill \\
Install path for Lua 5.2 modules, e.g. \texttt{\$(prefix)/share/lua/5.2}

\item[\texttt{lua52cpath}]  \hfill \\
Install path for Lua 5.2 C modules, e.g. \texttt{\$(prefix)/lib/lua/5.2}

\item[\texttt{lua53path}]  \hfill \\
Install path for Lua 5.3 modules, e.g. \texttt{\$(prefix)/share/lua/5.3}

\item[\texttt{lua53cpath}]  \hfill \\
Install path for Lua 5.3 C modules, e.g. \texttt{\$(prefix)/lib/lua/5.3}

\end{description}

\subsection{Targets}

\begin{description}

\item[\texttt{install}] \hfill \\
Install modules for Lua 5.1 and 5.2.

\item[\texttt{install5.1}] \hfill \\
Install Lua 5.1 module.

\item[\texttt{install5.2}] \hfill \\
Install Lua 5.2 module.

\item[\texttt{install5.3}] \hfill \\
Install Lua 5.3 module.

\end{description}


\chapter{Usage}

\section{Modules}

\begin{Module}{unix}

At present \lunix provides a single module of routines.

\subsubsection[\fn{environ[]}]{\fn{environ[]}}

Binding to the process-global \texttt{environ} array using metamethods.

\begin{description}
\item[\_\_index] \hfill \\
Utilizes the internal \fn{getenv} binding.
\item[\_\_newindex] \hfill \\
Utilizes the internal \fn{setenv} binding.
\item[\_\_pairs] \hfill \\
Takes a snapshot of the environ table to be used by the returned iterator for key--value loops. \emph{Other than Solaris\footnote{See https://blogs.oracle.com/pgdh/entry/caring\_for\_the\_environment\_making}, no system supports thread-safe access of the environ global.}
\item[\_\_ipairs] \hfill \\
Similar to \_\_pairs, but the iterator returns an index integer as the key followed by the environment variable as a single string---``FOO=BAR''.
\item[\_\_call] \hfill \\
Identical to the \_\_pairs metamethod, to be used to create an iterator directly as Lua 5.1 doesn't support \texttt{\_\_pairs}.
\end{description}

\subsubsection[\fn{accept}]{\fn{accept($file$[,$flags$])}}

FIXME.

\subsubsection[\fn{arc4random}]{\fn{arc4random()}}

Returns a cryptographically strong uniformly random 32-bit integer as a Lua number. On Linux the \const{RANDOM\_UUID} \fn{sysctl} feature is used to seed the generator if available; or on more recent Linux and Solaris kernels the \syscall{getrandom} interface.\footnote{Some Linux distributions, such as Red Hat, disable \syscall{sysctl}.} This avoids fiddling with file descriptors, and also works in a chroot jail. On other platforms without a native \fn{arc4random} interface, such as Solaris 11.2 or earlier, the implementation must resort to /dev/urandom for seeding.

Note that unlike the original implementation on OpenBSD, \fn{arc4random} on some older platforms (e.g. FreeBSD prior to 10.10) seeds itself from /dev/urandom. This could cause problems in chroot jails.

\subsubsection[\fn{arc4random\_buf}]{\fn{arc4random\_buf($n$)}}

Returns a string of length $n$ containing cryptographically strong random octets using the same CSPRNG underlying \fn{arc4random}.

\subsubsection[\fn{arc4random\_stir}]{\fn{arc4random\_stir()}}

Stir the arc4random entropy pool using the best available resources. This normally should be unnecessary.

\subsubsection[\fn{arc4random\_uniform}]{\fn{arc4random\_uniform([$n$])}}

Returns a cryptographically strong uniform random integer in the interval $[0, n-1]$ where $n \leq 2^{32}$. If $n$ is omitted the interval is $[0, 2^{32}-1]$ and effectively behaves like \fn{arc4random}.

\subsubsection[\fn{bind}]{\fn{bind($file$[,$sockaddr$])}}

FIXME.

\subsubsection[\fn{chdir}]{\fn{chdir($dir$)}}

If $dir$ is a string, attempts to change the current working directory using \syscall{chdir}. Otherwise, if $dir$ is a FILE handle referencing a directory, or an integer file descriptor referencing a directory, attempts to change the current working directory using \syscall{fchdir}.

Returns \true on success, otherwise returns \false, an error string, and an integer system error.

\subsubsection[\fn{chmod}]{\fn{chmod($file$, $mode$)}}

$file$ may be either be a string path for use with \syscall{chmod}, or a FILE handle or integer file descriptor for use with \syscall{fchmod}. $mode$ may be an integer value or symbolic string.

Returns \true on success, otherwise returns \false, an error string, and an integer system error.

\subsubsection[\fn{chown}]{\fn{chown($file$[, $uid$][, $gid$])}}

$file$ may be either be a string path for use with \syscall{chown}, or a FILE handle or integer file descriptor for use with \syscall{fchown}. $uid$ and $gid$ may be integer values or symbolic string names.

Returns \true on success, otherwise returns \false, an error string, and an integer system error.

\subsubsection[\fn{chroot}]{\fn{chroot($path$)}}

Attempt to \syscall{chroot} to the specified string $path$.

Returns \true on success, otherwise returns \false, an error string, and an integer system error.

\subsubsection[\fn{clock\_gettime}]{\fn{clock\_gettime($id$)}}

$id$ should be the string ``realtime'' or ``monotonic'', or the integer constant CLOCK\_REALTIME or CLOCK\_MONOTONIC.

Returns a time value as a Lua floating point number, otherwise returns \nil, an error string, and an integer system error.

\subsubsection[\fn{closedir}]{\fn{closedir($dir$)}}

Closes the DIR handle, releasing the underlying file descriptor.

\subsubsection[\fn{connect}]{\fn{connect($file$[,$sockaddr$])}}

FIXME.

\subsubsection[\fn{dup}]{\fn{dup($file$[, $flags$])}}

$file$ may be either a FILE handle or integer file descriptor. $flags$ is an optional file status flags integer. If available, \syscall{F\_DUPFD\_CLOEXEC} is used to ensure atomic setting of any \syscall{O\_CLOEXEC} flag.

Returns an integer descriptor on success, \otherwise{\nil}, an error string, and an integer system error.

\subsubsection[\fn{dup2}]{\fn{dup2($file$, $file$[, $flags$])}}

$file$ may be either a FILE handle or integer file descriptor. $flags$ is an optional file status flags integer. If available, either \syscall{dup3} or \syscall{F\_DUP2FD\_CLOEXEC} is used to ensure atomic setting of any \syscall{O\_CLOEXEC} flag.

Returns an integer descriptor on success, \otherwise{\nil}.

\subsubsection[\fn{dup3}]{\fn{dup3($file$, $file$, $flags$)}}

Like \syscall{dup2}, except $flags$ is not optional. This binding will not exist if \syscall{dup3} was not available at compile-time, whereas the \syscall{dup2} binding is best-effort regarding atomically setting \syscall{O\_CLOEXEC}.

\subsubsection[\fn{execve}]{\fn{execve($path$[, $argv$][, $env$])}}

Executes $path$, replacing the existing process image. $path$ should be an absolute pathname as the \$PATH environment variable is not used. $argv$ is a table or ipairs--iterable object specifying the argument vector to pass to the new process image. Traditionally the first such argument should be the basename of $path$, but this is not enforced. If absent or empty the new process image will be passed an empty argument vector. $env$ is a table or ipairs--iterable object specifying the new environment. If absent or empty the new process image will contain an empty environment.

On success never returns. On failure returns \false, an error string, and an integer system error.

\subsubsection[\fn{execl}]{\fn{execl($path$, $\ldots$)}}

Executes $path$, replacing the existing process image. The \$PATH environment variable is not used. Any subsequent arguments are passed to the new process image. The new process image inherits the current environment table.

On success never returns. On failure returns \false, an error string, and an integer system error.

\subsubsection[\fn{execlp}]{\fn{execlp($file$, $\ldots$)}}

Executes $file$, replacing the existing process image. The \$PATH environment variable is used to search for $file$. Any subsequent arguments are passed to the new process image. The new process image inherits the current environment table.

On success never returns. On failure returns \false, an error string, and an integer system error.

\subsubsection[\fn{execvp}]{\fn{execvp($file$[, $argv$])}}

Executes $file$, replacing the existing process image. The \$PATH environment variable is used to search for $file$. Any subsequent arguments are passed to the new process image. The new process image inherits the current environment table.

On success never returns. On failure returns \false, an error string, and an integer system error.

\subsubsection[\fn{\_exit}]{\fn{\_exit([$status$])}}

Exits the process immediately without first flushing and closing open streams, or calling \syscall{atexit} handlers. If $status$ is boolean \true or \false, exits with EXIT\_SUCCESS or EXIT\_FAILURE, respectively. Otherwise, $status$ is an optional integer status value which defaults to 0 (EXIT\_SUCCESS).

\subsubsection[\fn{exit}]{\fn{exit([$status$])}}

Like \fn{\_exit}, but first flushes and closes open streams, and calls \syscall{atexit} handlers.

\subsubsection[\fn{fcntl}]{\fn{fcntl($file$|$dir$|$fd$, \ldots)}}

FIXME

\subsubsection[\fn{fdatasync}]{\fn{fdatasync($file$|$dir$|$fd$)}}

FIXME

\subsubsection[\fn{fdopen}]{\fn{fdopen($file$|$dir$|$fd$[, $mode$])}}

FIXME

\subsubsection[\fn{fdopendir}]{\fn{fdopendir($file$|$dir$|$fd$)}}

FIXME

\subsubsection[\fn{fdup}]{\fn{fdup($file$[, $flags$])}}

$file$ may be either a FILE handle or integer file descriptor. $flags$ is an optional integer or symbolic mode.

Returns a FILE handle on success, otherwise returns \nil, an error string, and an integer system error.

\subsubsection[\fn{fileno}]{\fn{fileno($file$|$dir$|$fd$)}}

Resolves the specified FILE handle or DIR handle to an integer file descriptor. An integer descriptor is returned as-is.

\subsubsection[\fn{flockfile}]{\fn{flockfile($fh$)}}

Locks the FILE handle $fh$, blocking the current thread if already locked. Returns \true.

This function only works on FILE handles and not DIR handlers or integer descriptors.

\subsubsection[\fn{fstat}]{\fn{fstat($path$|$file$|$dir$|$fd$[, $field$ \ldots])}}

See \fn{stat}.

\subsubsection[\fn{fsync}]{\fn{fsync($file$|$dir$|$fd$)}}

FIXME

\subsubsection[\fn{ftrylockfile}]{\fn{ftrylockfile($fh$)}}

Attempts to lock the FILE handle $fh$. Returns \true on success or \false if $fh$ was locked by another thread.

\subsubsection[\fn{funlockfile}]{\fn{funlockfile($fh$)}}

Unlocks the FILE handle $fh$. Returns \true.

\subsubsection[\fn{fopen}]{\fn{fopen($path$|$file$|$dir$|$fd$[, $mode$][, $perm$])}}

Similar to the \syscall{open} binding except returns a FILE handle. Unlike Lua's \texttt{io.open} routine,
any string $mode$ is passed directly to the \syscall{fopen} interface and thus supports all local extensions. One consequence of this is that if $mode$ is a string then $perm$ is ignored. To ensure that \syscall{fopen} is invoked both $path$ and $mode$ should be strings, otherwise the semantics are emulated by translating $mode$ to an integer bitfield and invoking \syscall{open}.

Returns a FILE handle on success, otherwise \nil, an error string, and an integer system error.

The difference between calling \syscall{fopen} versus \syscall{open}+\syscall{fdopen} is that the \syscall{fopen} binding ensures that a descriptor is not leaked if \syscall{fdopen} fails or throws an exception.

\subsubsection[\fn{fopenat}]{\fn{fopenat($path$[, $mode$][, $perm$])}}

See \syscall{openat} and \syscall{fopen}.

Returns a FILE handle on success, otherwise \nil, an error string, and an integer system error.

\subsubsection[\fn{fpipe}]{\fn{fpipe([$mode$])}}

FIXME.

\subsubsection[\fn{fork}]{\fn{fork()}}

Forks a new process. On success returns the PID of the new process in the parent and the integer 0 in the child. Otherwise returns \false, an error string, and an integer system error.

\subsubsection[\fn{gai\_strerror}]{\fn{gai\_strerror($error$)}}

Returns an error string corresponding to the specified \texttt{EAI} integer $error$.

\subsubsection[\fn{getaddrinfo}]{\fn{getaddrinfo($host$, [$port$], [$hints$][, $field$ \ldots])}}

Returns an iterator over the addresses resolved for $host$ and $port$. If a resolution error occurred, returns \nil, an error string, an \texttt{EAI} error integer, and a system error integer (if \texttt{EAI} error is \texttt{EAI\_SYSTEM}).

$host$ should be a string host name. $port$ is an optional port number which defaults to 0.

$hints$ is an optional table controlling the manner and scope of resolution. For example, if a family is not specified the resolver will return a unique result for each address-family combination supported by the system. The following fields are supported:

\begin{description}
\item[.flags] \hfill \\
Bitwise or of one of more of \texttt{AI\_PASSIVE}, \texttt{AI\_CANONNAME}, \texttt{AI\_NUMERICHOST}, \texttt{AI\_NUMERICSERV}, \texttt{AI\_ADDRCONFIG}, \texttt{AI\_V4MAPPED} (if supported), and \texttt{AI\_ALL} (if supported).
\item[.family] \hfill \\
AF\_UNSPEC, AF\_INET, or AF\_INET6.
\item[.socktype] \hfill \\
SOCK\_DGRAM, SOCK\_STREAM, or SOCK\_SEQPACKET (if supported).
\item[.protocol] \hfill \\
IPPROTO\_IP, IPPROTO\_IPV6, IPPROTO\_TCP, IPPROTO\_UDP, IPPROTO\_ICMP, or IPPROTO\_RAW (if supported).
\end{description}

If no fields are specified, the iterator returns a table with the following fields:

\begin{description}
\item[.family] \hfill \\
See description of family for hints table.
\item[.socktype] \hfill \\
See description of socktype for hints table.
\item[.protocol] \hfill \\
See description of protocol for hints table. 
\item[.addr] \hfill \\
IP address as human-readable string.
\item[.canonical] \hfill \\
Canonical hostname of IP address (if AI\_CANONNAME flag was specified in hints table).
\item[.port] \hfill \\
Integer port.
\end{description}

If fields are specified, the iterator returns a list of fields in the order specified.

\subsubsection[\fn{getnameinfo}]{\fn{getnameinfo($sockaddr$[, $flags$])}}

FIXME.

\subsubsection[\fn{getegid}]{\fn{getegid()}}

Returns the effective process GID as a Lua number.

\subsubsection[\fn{getenv}]{\fn{getenv($name$)}}

Returns the value of the environment variable $name$ as a string, or \nil if it does not exist.

\emph{Not thread-safe on any system other than Solaris\footnote{See https://blogs.oracle.com/pgdh/entry/caring\_for\_the\_environment\_making} and NetBSD\footnote{NetBSD provides \syscall{getenv\_r(3)}}. Linux/glibc \fn{getenv} is thread-tolerant as pointers returned from \syscall{getenv} will remain valid throughout the lifetime of the process, but Linux/glibc will write over existing values on update so concurrent use with \fn{setenv} could lead to inconsistent views.}

\subsubsection[\fn{geteuid}]{\fn{geteuid()}}

Returns the effective process UID as a Lua number.

\subsubsection[\fn{getgroups}]{\fn{getgroups()}}

Queries supplement group list. On success returns an array of supplement GIDs. Otherwise returns \nil, an error string, and an integer system error.

\subsubsection[\fn{getmode}]{\fn{getmode($mode$[, $omode$])}}

The \fn{getmode} interface derives from the routine so-named in almost every \texttt{chmod(1)} utility implementation and which exposes the parser for symbolic file permissions.

$mode$ should be a symbolic mode value with a valid syntax as described by POSIX within the \syscall{chmod(1)} utility man page. If specified, $omode$ should be an integer or a string in decimal, hexidecimal, or octal notation, and represents the original mode value used by the symbolic syntax for inheritance.

\subsubsection[\fn{getgid}]{\fn{getgid()}}

Returns the real process GID as a Lua number.

\subsubsection[\fn{getgrnam}]{\fn{getgrnam($grp$[, $\ldots$])}}

$grp$ is an integer GID or string symbolic group name suitable for use by either \syscall{getgrgid(3)} or \syscall{getgrnam(3)}, respectively.

If no other arguments are specified, on success returns a table with the following fields

\begin{description}
\item[.name] \hfill \\
Symbolic group name as a string, or \nil if absent.
\item[.passwd] \hfill \\
Password information as a string, or \nil if absent.
\item[.gid] \hfill \\
GID as integer.
\item[.mem] \hfill \\
Array of supplementary group names, or \nil if absent.
\end{description}

If additional arguments are given, on success each field specified (as named above) is returned as part of the return value list. ``members'' may be used as an alternative to ``mem''. Note that the return value may be \nil if the field was absent.

If no group was found, returns \nil followed by the error string ``no such group''.

If a system error occurred, returns \nil, an error string, and an integer system error.

\subsubsection[\fn{getgroups}]{\fn{getgroups()}}

Returns table of supplementary GIDs on success, otherwise \nil, an error string, and an integer system error.

\subsubsection[\fn{gethostname}]{\fn{gethostname()}}

Returns system hostname as string on success, otherwise \nil, an error string, and an integer system error.

\subsubsection[\fn{getifaddrs}]{\fn{getifaddrs([$\ldots$])}}

Returns an iterator over the current system network interfaces on success. If a system error occurred, returns \nil, an error string, and an integer system error.

If no arguments are specified, each invocation of the iterator returns a table with the following fields

\begin{description}
\item[.name] \hfill \\
Interface symbolic name as a string.
\item[.flags] \hfill \\
Interface flags as an integer bit field.
\item[.family] \hfill \\
Interface address family as an integer.
\item[.addr] \hfill \\
Interface address as a string, or \nil if of an unknown address family.
\item[.netmask] \hfill \\
Interface address netmask as a string, or \nil if absent or of an unknown address family.
\item[.prefixlen] \hfill \\
Interface address prefixlen as an integer, or \nil if absent or of an unknown address family.
\item[.dstaddr] \hfill \\
Interface destination address if point-to-point, or \nil if absent or of an unknown address family.
\item[.broadaddr] \hfill \\
Interface broadcast address, or \nil if absent or of an unknown address family.
\end{description}

If arguments are given, each field specified (as named above) is returned as part of the return value list on every invocation of the iterator.

\subsubsection[\fn{getpeername}]{\fn{getpeername($file$)}}

FIXME.

\subsubsection[\fn{getpgid}]{\fn{getpgid()}}

FIXME.

\subsubsection[\fn{getpgrp}]{\fn{getpgrp()}}

FIXME.

\subsubsection[\fn{getpid}]{\fn{getpid()}}

Returns the process ID as a Lua number.

\subsubsection[\fn{getppid}]{\fn{getppid()}}

Returns the parent process ID as a Lua number.

\subsubsection[\fn{getprogname}]{\fn{getprogname()}}

Returns the program name as a string, otherwise \nil, an error string, and an integer system error.

\subsubsection[\fn{getpwnam}]{\fn{getpwnam($usr$[, $\ldots$])}}

$usr$ is an integer UID or string symbolic user name suitable for use by either \syscall{getpwuid(3)} or \syscall{getpwnam(3)}, respectively.

If no other arguments are specified, on success returns a table with the following fields

\begin{description}
\item[.name] \hfill \\
Symbolic user name as a string, or \nil if absent.
\item[.passwd] \hfill \\
Password information as a string, or \nil if absent.
\item[.uid] \hfill \\
UID as integer.
\item[.gid] \hfill \\
Primary GID as integer.
\item[.dir] \hfill \\
Home directory path, or \nil if absent.
\item[.shell] \hfill \\
Login shell path, or \nil if absent.
\item[.gecos] \hfill \\
Additional user information, or \nil if absent.
\end{description}

If additional arguments are given, on success each field specified (as named above) is returned as part of the return value list. Note that the return value may be \nil if the value was empty in the database.

If no user was found, returns \nil followed by the error string ``no such user''.

If a system error occurred, returns \nil, an error string, and an integer system error.

\subsubsection[\fn{getrlimit}]{\fn{getrlimit([$what$])}}

FIXME.

\subsubsection[\fn{getrusage}]{\fn{getrusage([$who$])}}

FIXME.

\subsubsection[\fn{getsockname}]{\fn{getsockname($file$)}}

FIXME.

\subsubsection[\fn{gettimeofday}]{\fn{gettimeofday([$ints$])}}

Returns the current time as a Lua floating point number or, if $ints$ is \true, as two integers representing seconds and microseconds.

On failure returns \nil, an error string, and an integer system error.

\subsubsection[\fn{getuid}]{\fn{getuid()}}

Returns the real process UID as a Lua number.

\subsubsection[\fn{grantpt}]{\fn{grantpt($file$)}}

FIXME.

\subsubsection[\fn{ioctl}]{\fn{ioctl($file$, \ldots)}}

FIXME.

\subsubsection[\fn{isatty}]{\fn{isatty($file$)}}

FIXME.

\subsubsection[\fn{issetugid}]{\fn{issetugid()}}

Returns \true if the process environment is considered unsafe because of setuid, setgid, or similar operations, otherwise \false.

\subsubsection[\fn{kill}]{\fn{kill($pid$, $signo$)}}

Sends signal $signo$ to process or process group $pid$. Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{lchown}]{\fn{lchown($path1$[, $uid$][, $gid$])}}

FIXME.

\subsubsection[\fn{link}]{\fn{link($path1$, $path2$)}}

Creates a new directory entry at $path2$ as a hard link to $path1$.

Returns \true on success, otherwise \false, an error string, and an integer system error. 

\subsubsection[\fn{lockf}]{\fn{lockf($file$, $cmd$[, $size$])}}

FIXME.

\subsubsection[\fn{lseek}]{\fn{lseek($file$, $offset$, $whence$)}}

FIXME.

\subsubsection[\fn{lstat}]{\fn{lstat($path$[, $field$ \ldots])}}

Identical to \fn{stat}, except only accepts string paths and uses the \syscall{lstat} system call.

\subsubsection[\fn{mkdir}]{\fn{mkdir($path$[, $mode$])}}

Create a new directory at $path$. $mode$, if specified, should be a symbolic mode string following the POSIX syntax as described by the \texttt{chmod(1)} utility man page. Otherwise, $mode$ defaults to 0777. In either case, $mode$ is masked by the process umask.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{mkdirat}]{\fn{mkdirat($fd$|$file$|$dir$, $path$[, $mode$])}}

Similar to \syscall{mkdir} except interprets $path$ relative to the specified open directory file descriptor, $fd$, or a FILE handle or DIR handle that wraps such a descriptor.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{mkfifo}]{\fn{mkfifo($path$[, $mode$])}}

Create a FIFO at $path$. $mode$, if specified, should be an integer bitfield or symbolic string following the POSIX syntax as described by the \texttt{chmod(1)} utility man page. Otherwise, $mode$ defaults to 0666.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{mkfifoat}]{\fn{mkfifoat($fd$|$file$|$dir$, $path$[, $mode$])}}

Similar to \syscall{mkfifo} except interprets $path$ relative to the specified open directory file descriptor, $fd$, or a FILE handle or DIR handle that wraps such a descriptor.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{mkpath}]{\fn{mkpath($path$[, $mode$][, $imode$])}}

Like \fn{mkdir}, but also creates intermediate directories if missing. $imode$ is the mode for intermediate directories. Like $mode$ it is restricted by the process umask, but unlike $mode$ the user write bit is unconditionally set to ensure the full path can be created.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{open}]{\fn{open($path$|$file$|$dir$|$fd$[, $mode$][, $perm$])}}

Open the specified file. Normally a string path is specified. If a FILE handle, DIR handle, or file descriptor are specified the library will attempt to use system extensions to create a new file descriptor. Unlike \syscall{dup} this descriptor will not share status flags or file position cursors. (This will only work on Linux, NetBSD, and Solaris with procfs support; or on macOS using the special ``/.vol'' namespace. macOS and Solaris only support re-opening file system objects this way, not pipes or sockets. The BSD ``/dev/fd'' namespace has semantics equivalent to \syscall{dup}, except on Linux where ``/dev/fd'' is a symlink to ``/proc/self/fd''.)

$mode$ specifies the open flags as an integer bitfield (e.g. \texttt{O\_CREAT|O\_RDWR}, \texttt{O\_RDONLY|O\_CLOEXEC}, etc) or a symbolic string (e.g. ``w+x''). If unspecified defaults to \texttt{0}, which normally equals \texttt{O\_RDONLY}.

$perm$ specifies the file creation mode bits as an integer bitfield or a symbolic string (e.g. ``ug+rw,o+r'', equivalent to \texttt{0644}). If unspecified defaults to \texttt{0666}.\footnote{Note that the kernel will apply the process-global file mode creation mask to the permission bits. See \syscall{umask}.}

Returns an integer file descriptor on success, otherwise \nil, an error string, and an integer system error.

\subsubsection[\fn{openat}]{\fn{openat($file$|$dir$|$fd$, $path$[, $mode$][, $perm$])}}

Similar to \syscall{open} except the first parameter should resolve to an open directory file descriptor.

Returns an integer file descriptor on success, otherwise \nil, an error string, and an integer system error.

\subsubsection[\fn{opendir}]{\fn{opendir($path$|$file$|$dir$|$fd$)}}

Creates a DIR handle for reading directory entries. Caller may specify a path string, a Lua FILE handle, another DIR handle, or an integer descriptor. In the latter three cases, the underlying descriptor is duplicated using \syscall{dup3} (if available) or \syscall{dup2} because there's no safe way to steal the descriptor from existing FILE or DIR handles. But it's not a good idea to mix reads between the two original and duplicated descriptors as they will normally share the same open file entry in the kernel, including the same position cursor.\footnote{In the future may add ability to open /proc/self/fd or /dev/fd entries, which should create a new open file entry.}

Returns a DIR handle on success, otherwise nil, an error string, and an integer system error.

\subsubsection[\fn{pipe}]{\fn{pipe($mode$)}}

FIXME.

\subsubsection[\fn{poll}]{\fn{poll($fds$[, $timeout$])}}

Polls on the file descriptor events specified by $fds$. Following the \luaposix API, $fds$ is a table indexed by integer file descriptors, each table entry another table with the integer bitmak field ``events'' specifying desired events to poll. $timeout$ is an optional floating-pointing value specifying the number of seconds (and fractions thereof) to block. A missing or \nil timeout will wait forever; a negative value is assumed to be the result of arithmetic underflow and effects a 0-second timeout.\footnote{In other words, do not pass $-1$ as-if directly calling the underlying system call.}

On success updates the ``revents'' field for each descriptor entry in $fds$ and returns the number of ready descriptors; \otherwise{\nil}.

\begin{example}{lua}
local fds = { [fd] = { events = unix.POLLIN } }
local nr = assert(unix.poll(fds, 3.0))
for fd, t in pairs(fds) do
  -- see Appendix for strevents implementation
  print(fd, strevents(t.events), strevents(t.revents))
end
\end{example}

\subsubsection[\fn{posix\_fadvise}]{\fn{posix\_fadvise($file$, $offset$, $len$, $advice$)}}

FIXME.

\subsubsection[\fn{posix\_fallocate}]{\fn{posix\_fallocate($file$, $offset$, $len$)}}

FIXME.

\subsubsection[\fn{posix\_openpt}]{\fn{posix\_openpt([$flags$])}}

FIXME.

\subsubsection[\fn{posix\_fopenpt}]{\fn{posix\_fopenpt([$flags$])}}

FIXME.

\subsubsection[\fn{pread}]{\fn{pread($file$, $size$, $offset$)}}

Reads up to $size$ bytes of data from $file$ at $offset$. $file$ may be either a FILE handle or integer file descriptor.

Returns a string on success, \otherwise{\nil}.

\subsubsection[\fn{ptsname}]{\fn{ptsname($file$)}}

FIXME.

\subsubsection[\fn{pwrite}]{\fn{pwrite($file$, $data$, $offset$)}}

Writes $data$ to $file$ at $offset$. $file$ may be either a FILE handle or integer file descriptor.

Returns an integer representing the number of bytes written (which may be less than \texttt{\#data}) on success, \otherwise{\nil}.

\subsubsection[\fn{raise}]{\fn{raise($signo$)}}

Sends signal $signo$ to calling thread. Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{read}]{\fn{read($file$, $size$)}}

Reads up to $size$ bytes of data from $file$. $file$ may be either a FILE handle or integer file descriptor.

Returns a string on success, \otherwise{\nil}.

\subsubsection[\fn{readdir}]{\fn{readdir($dir$[, $field$ $\ldots$])}}

Reads the next directory entry. If no field arguments are specified, on success returns a table with the following fields

\begin{description}
\item[.name] \hfill \\
Name of file.
\item[.ino] \hfill \\
Inode of file.
\item[.type] \hfill \\
A numeric value describing the file type, similar to the ``mode'' field returned by \syscall{stat}, except without any permission bits present. You can pass this value to \fn{S\_ISREG}, \fn{S\_ISDIR}, \fn{S\_ISFIFO}, etc.

Available on Linux and BSD derivatives, but, e.g., will be \nil on Solaris.
\end{description}

If additional arguments are given, on success each field specified (as named above) is returned as part of the return value list. Note that the return value may be \nil if the value was unavailable.

If the end of directory entries has been reached, returns \nil.

If a system error occurred, returns \nil, an error string, and an integer system error.

\subsubsection[\fn{recv}]{\fn{recv($file$, $size$[, $flags$])}}

Receives up to $size$ bytes of data from the socket $file$. $file$ may be either a FILE handle or integer file descriptor. $flags$ is an optional integer containing bitwise socket receive flags (e.g. \texttt{MSG\_WAITALL}).

Returns a string on success, \otherwise{\nil}.

\subsubsection[\fn{recvfrom}]{\fn{recvfrom($file$, $size$[, $flags$])}}

Like \syscall{recv}. Returns a string and \sockaddr on success; \otherwise{\nil}.

\subsubsection[\fn{recvfromto}]{\fn{recvfromto($file$, $size$[, $flags$])}}

\label{recvfromto}

Like \syscall{recvfrom}. Returns a string, source \sockaddr, and destination \sockaddr on success; \otherwise{\nil}.

This interface is useful for replying to UDP packets with the same source address received on, without having to enumerate, bind, and listen on multiple interfaces. Because interfaces can go down and come up dynamically, binding on multiple interfaces is complex and difficult. See also the reciprocal interface, \seefn{sendtofrom}.

NOTES:
\begin{itemize}
\item Not all platforms support this interface. AIX (confirmed 7.1) supports IPv6 but not IPv4.
\item The descriptor \mustbe initialized by enabling a specialized socket option. The option varies by platform and socket protocol family. See \seefn{setrecvaddr} example in Appendix.
\end{itemize}

\subsubsection[\fn{rename}]{\fn{rename($from$, $to$)}}

Renames the file $from$ to $to$. The paths must reside on the same device.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{renameat}]{\fn{renameat($fromfd$, $from$, $tofd$, $to$)}}

Similar to \syscall{rename} except interprets the string paths $from$ and $to$ relative to the respective open directory file descriptor, $fromfd$ and $tofd$, respectively. $fromfd$ and $tofd$ should be integer file descriptors to an open directory, or FILE handles or DIR handles that wrap such descriptors.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{rewinddir}]{\fn{rewinddir($dir$)}}

Rewinds the DIR handle so the directory entries may be read again.

\subsubsection[\fn{rmdir}]{\fn{rmdir($path$)}}

Remove the directory at $path$.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{S\_ISBLK}]{\fn{S\_ISBLK($mode$)}}

Tests whether the specified $mode$ value---as returned by, e.g., \syscall{stat} or \syscall{readdir}---represents a block device.

Returns \true or \false.

\subsubsection[\fn{S\_ISCHR}]{\fn{S\_ISCHR($mode$)}}

Tests whether the specified $mode$ value---as returned by, e.g., \syscall{stat} or \syscall{readdir}---represents a character device.

Returns \true or \false.

\subsubsection[\fn{S\_ISDIR}]{\fn{S\_ISDIR($mode$)}}

Tests whether the specified $mode$ value---as returned by, e.g., \syscall{stat} or \syscall{readdir}---represents a directory.

Returns \true or \false.

\subsubsection[\fn{S\_ISFIFO}]{\fn{S\_ISFIFO($mode$)}}

Tests whether the specified $mode$ value---as returned by, e.g., \syscall{stat} or \syscall{readdir}---represents a FIFO or pipe.

Returns \true or \false.

\subsubsection[\fn{S\_ISREG}]{\fn{S\_ISREG($mode$)}}

Tests whether the specified $mode$ value---as returned by, e.g., \syscall{stat} or \syscall{readdir}---represents a regular file.

Returns \true or \false.

\subsubsection[\fn{S\_ISLNK}]{\fn{S\_ISLNK($mode$)}}

Tests whether the specified $mode$ value---as returned by, e.g., \syscall{stat} or \syscall{readdir}---represents a symbolic link.

Returns \true or \false.

\subsubsection[\fn{S\_ISSOCK}]{\fn{S\_ISSOCK($mode$)}}

Tests whether the specified $mode$ value---as returned by, e.g., \syscall{stat} or \syscall{readdir}---represents a socket.

Returns \true or \false.

\subsubsection[\fn{send}]{\fn{send($file$, $data$[, $flags$])}}

Sends $data$ to the peer on the socket, $file$. $file$ may be either a FILE handle or integer file descriptor. $flags$ is an optional integer containing bitwise socket send flags (e.g. \texttt{MSG\_NOSIGNAL}).

Returns an integer representing the number of bytes sent (which may be less than \texttt{\#data}) on success, \otherwise{\nil}.

\subsubsection[\fn{sendto}]{\fn{sendto($file$, $data$, $flags$, $to\_addr$}}

Like \syscall{send}. $to\_addr$ is a \sockaddr destination address or table convertible to a \sockaddr

\subsubsection[\fn{sendtofrom}]{\fn{sendtofrom($file$, $data$, $flags$, $to\_addr$, $from\_addr$)}}

\label{sendtofrom}

Like \syscall{send}. $to\_addr$ is a \sockaddr destination address or table convertible to a \sockaddr, and $from\_addr$ a \sockaddr source address or table convertible to a \sockaddr. See also the reciprocal interface, \seefn{recvfromto}.

NOTES:
\begin{itemize}
\item Not all platforms support this interface. AIX (confirmed 7.1), NetBSD (confirmed 7.0), and OpenBSD <= 6.0 (confirmed 6.0) support IPv6 but not IPv4.
\item FreeBSD (confirmed 10.1) requires the socket to be bound to the wildcard address, ``0.0.0.0'' or ``::''.
\item macOS 10.10 and several prior releases contain a kernel bug which causes a kernel panic if the socket address is not bound as required by FreeBSD. (Oddly macOS copied Linux's \texttt{IP\_PKTINFO} interface, not FreeBSD's \texttt{IP\_SENDSRCADDR}; but Linux doesn't have the requirement to bind).
\end{itemize}

\subsubsection[\fn{setegid}]{\fn{setegid($gid$)}}

Set the effective process GID to $gid$. $gid$ must be an integer or symbolic group name.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{seteuid}]{\fn{seteuid($uid$)}}

Set the effective process UID to $uid$. $uid$ must be an integer or symbolic user name.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{setenv}]{\fn{setenv($name$, $value$[, $overwrite$])}}

Sets the environment variable $name$ to $value$. If the variable already exists then it is not changed unless $overwrite$ is \true. $overwrite$ defaults to $true$.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\emph{This function is thread-safe on Solaris and NetBSD. For Linux/glibc see note at \fn{getenv}. FreeBSD, OpenBSD, and Linux/musl are confirmed to be not thread-safe. The status of AIX and OS X is unknown. In general \fn{setenv} should be avoided in multi-threaded environments.}

\subsubsection[\fn{setgid}]{\fn{setgid($gid$)}}

Set the real process GID to $gid$. $gid$ must be an integer or symbolic group name.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{setgroups}]{\fn{setgroups\{ \ldots \}}}

Sets the supplement group list. Takes an array of GIDs. On success returns \true. Otherwise returns \false, an error string, and an integer system error.

As an extension, group names may be specified instead of integer GIDs. However, an unresolvable group name currently causes an error to be thrown rather than returned. Until this is fixed, use \fn{getgrnam} to explicitly resolve names to GIDs.

\subsubsection[\fn{setlocale}]{\fn{setlocale($category$ [, $locale$])}}

Set or query the program locale. $category$ is an integer constant which specifies the category of localization, and should be one of \texttt{LC\_ALL}, \texttt{LC\_COLLATE}, \texttt{LC\_CTYPE}, \texttt{LC\_MONETARY}, \texttt{LC\_NUMERIC}, or \texttt{LC\_TIME}.

$locale$ can be either a string identifier for the locale, or \nil to query the specified category. An empty locale string selects the system's native locale.

Returns a locale string identifier on success, otherwise \nil if the specified $category$ and $locale$ could not be honored.

\subsubsection[\fn{setpgid}]{\fn{setpgid($pid$, $pgid$)}}

FIXME.

\subsubsection[\fn{setrlimit}]{\fn{setrlimit($what$[, $soft$][, $hard$])}}

FIXME.

\subsubsection[\fn{setsid}]{\fn{setsid()}}

Create a new session and process group.

Returns the new process group ID on success, otherwise \nil, an error string, and an integer system error.

\subsubsection[\fn{setsockopt}]{\fn{setsockopt($file$, $level$, $type$, \ldots)}}

FIXME.

\subsubsection[\fn{setuid}]{\fn{setuid($uid$)}}

Set the real process UID to $uid$. $uid$ must be an integer or symbolic user name.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{sigaction}]{\fn{sigaction($signo$, [$action$], [$oaction$])}}

Sets or queries the signal disposition for the signal $signo$.

If specified, $action$ is a table used to update the signal disposition.

\begin{description}
\item[.handler] \hfill \\
Currently handler may only be \texttt{SIG\_DFL}, \texttt{SIG\_ERR}, or \texttt{SIG\_IGN}.
Lua functions are not currently supported, but may in the future. In the meantime, applications can use \fn{sigtimedwait} to atomically dequeue signals in a thread-safe manner.
\item[.mask] \hfill \\
A sigset\_t userdata object, or the string ``*'' (see \fn{sigfillset}).
\item[.flags] \hfill \\
Bitwise or of one or more of SA\_NOCLDSTOP, SA\_ONSTACK, SA\_RESETHAND, SA\_RESTART, SA\_SIGINFO, SA\_NOCLDWAIT, and SA\_NODEFER.
\end{description}

Returns \true on success if $oaction$ is \nil or \false.

Returns a table on success if $oaction$ is \true. The table describes the signal disposition at the time \syscall{sigaction} was initially called.

Otherwise returns \nil, an error string, and an integer system error.

\subsubsection[\fn{sigfillset}]{\fn{sigfillset([$set$])}}

Returns a sigset\_t userdata object with all bits filled. If $set$ is specified should be an existing
sigset\_t userdata object to reuse.

\subsubsection[\fn{sigemptyset}]{\fn{sigemptyset([$set$])}}

Returns a sigset\_t userdata object with all bits cleared. If $set$ is specified should be an existing
sigset\_t userdata object to reuse.

\subsubsection[\fn{sigaddset}]{\fn{sigaddset($set$[, $signo$ $\ldots$])}}

Returns a sigset\_t userdata object with the specified signals set. If $set$ is not a sigset\_t object, a new, empty sigset\_t is instantiated and initialized according to whether $set$ is \nil, an integer signal number, an array of integer signal numbers, or the string ``*'' (filled) or ``'' (empty). If specified, $signo$ and additional arguments should be integer signal numbers to be added to the sigset\_t object.

\subsubsection[\fn{sigdelset}]{\fn{sigdelset($set$[, $signo$ $\ldots$])}}

Like \fn{sigaddset}, but $signo$ and subsequent integer signal numbers are cleared from the sigset\_t object.

\subsubsection[\fn{sigismember}]{\fn{sigismember($set$, $signo$)}}

Returns \true if $signo$ is a member of sigset\_t $set$, otherwise false.

\subsubsection[\fn{sigprocmask}]{\fn{sigprocmask([$how$, $set$[, $oset$]])}}

If $how$ and $set$ are defined, sets the signal mask of the current process or thread. $how$ should be one of \texttt{SIG\_BLOCK}, \texttt{SIG\_UNBLOCK}, or \texttt{SIG\_SETMASK}. $set$ should be a sigset\_t userdata object, or a number, string, or array suitable for initializing a sigset\_t object as discussed in \fn{sigaddset}.

Returns the old mask as a sigset\_t userdata object on success, otherwise \nil, an error string, and an integer system error. $oset$ is an optional sigset\_t userdata object to be reused as the return value, and is first cleared before passing to the system call.

\emph{Whether the process or thread mask is set is implementation defined, and varies across platforms. Threaded applications should use \syscall{pthread\_sigmask}, which is guaranteed to set the mask of the current thread.\footnote{Use of \syscall{pthread\_sigmask} requires linking with --lpthread on some platforms and for this reason is presently not supported by \lunix.} Unfortunately, there is no interface which is guaranteed to only set the process mask. New threads inherit the mask of the creating thread, so standard practice is typically to block everything in the main thread while creating new threads.}

\subsubsection[\fn{sigtimedwait}]{\fn{sigtimedwait($set$[, $timeout$])}}

Atomically clears any pending signal specified in $set$ from the pending set of the process \emph{and} thread. If none are pending, waits for $timeout$ seconds, or indefinitely if $timeout$ is not specified. Fractional seconds are supported.

On success returns an integer signal number cleared from the pending set and an array representing the members of the siginfo\_t structure (without the ``si\_'' prefix).\footnote{Currently only the .si\_signo member is copied from siginfo\_t.} On error returns \nil, an error string, and an integer system error. If $timeout$ is specified and no signal was cleared before the timeout, the system error will be \texttt{ETIMEDOUT}.

\emph{OS X and OpenBSD lack a native \syscall{sigtimedwait} implementation. On OS X \lunix uses \syscall{sigpending} and \syscall{sigwait} to emulate the behavior. However, in a multi--threaded application if another thread clears a signal between \syscall{sigpending} and \syscall{sigwait} then \syscall{sigwait} could block indefinitely. There's no way to solve this race condition.\footnote{One possible solution is to explicitly \syscall{raise} the signal before calling \syscall{sigpending}, but this solutions relies on untested assumptions about signal handling on these platforms.} On OpenBSD \syscall{sigwait} is only available through libpthread, but on OpenBSD libpthread must be loaded at process load--time and cannot be brought in as a \syscall{dlopen} run--time dependency. Therefore an alternative emulation is used which clears the pending signal by installing a noop signal handler. This is not thread-safe if another thread is also installing a signal handler simultaneously. Threaded applications on these platforms should be mindful of these limitations. The \cqueues project supports thread-safe signal listening with \syscall{kqueue} on both OpenBSD and Mac OS X.}

\subsubsection[\fn{sigwait}]{\fn{sigwait($set$)}}

FIXME.

\subsubsection[\fn{sleep}]{\fn{sleep($n$)}}

FIXME.

\subsubsection[\fn{stat}]{\fn{stat($path$|$file$|$dir$|$fd$[, $field$ $\ldots$])}}

Stats the specified file. Caller may specify a path string, a Lua FILE handle, a DIR handle (see \fn{opendir}), or an integer descriptor.

If no field arguments are specified, on success returns a table with the following fields

\begin{description}
\item[.dev] \hfill \\
Device identifier as integer of device containing file.
\item[.ino] \hfill \\
Inode identifier as integer.
\item[.mode] \hfill \\
Mode---type, permissions, etc---as integer.
\item[.nlink] \hfill \\
Link count as integer.
\item[.uid] \hfill \\
Owner UID as integer.
\item[.gid] \hfill \\
Owner GID as integer.
\item[.rdev] \hfill \\
Device identifer as integer if character or block special file.
\item[.size] \hfill \\
File size as integer.
\item[.atime] \hfill \\
Last data access timestamp as floating-point number with sub-second fractional component\footnote{All platforms currently support timestamps with sub-second precision. However, the underlying filesystem may not record a timestamp with sub-second precision.}.
\item[.mtime] \hfill \\
Last data modification timestamp as floating-point number with sub-second fractional component.
\item[.ctime] \hfill \\
Last file status change timestamp as floating-point number with sub-second fractional component.
\item[.blksize] \hfill \\
File-system-specified preferred I/O block size as integer.
\item[.blocks] \hfill \\
Number of blocks allocated for this object as integer.
\end{description}

If field arguments are given, on success each field specified (as named above) is returned as part of the return value list. Note that the return value may be \nil if the value was unavailable.

On error returns \nil, an error string, and an integer system error.

\subsubsection[\fn{strerror}]{\fn{strerror($error$)}}

Returns an error string corresponding to the specified system $error$ integer.

\subsubsection[\fn{strsignal}]{\fn{strsignal($signo$)}}

Returns a string describing the specified signal number.

\subsubsection[\fn{symlink}]{\fn{symlink($path1$, $path2$)}}

Creates a new directory entry at $path2$ as a symbolic link to $path1$.

Returns \true on success, otherwise \false, an error string, and an integer system error. 

\subsubsection[\fn{tcgetpgrp}]{\fn{tcgetpgrp($file$)}}

FIXME.

\subsubsection[\fn{tcsetpgrp}]{\fn{tcsetpgrp($file$, $pgid$)}}

FIXME.

\subsubsection[\fn{timegm}]{\fn{timegm($tm$)}}

$tm$ is a table of the form returned by the Lua routine \fn{os.date("*t")}. This allows converting a datetime in GMT directly to a POSIX timestamp without having to change the process timezone, which is inherently non-thread-safe.

Returns a POSIX timestamp as a Lua number.

\subsubsection[\fn{truncate}]{\fn{truncate($file$[, $size$])}}

Truncate $file$ to $size$ bytes (defaults to 0). $file$ should be a string path, or \const{FILE} handle or integer file descriptor.

Returns \true on success, otherwise \false, an error string, and an integer system error. 

\subsubsection[\fn{tzset}]{\fn{tzset()}}

Initializes datetime conversion information according to the TZ environment variable, if available.

Return \true.

\subsubsection[\fn{umask}]{\fn{umask([$cmask$])}}

If $cmask$ is specified, sets the process file creation mask and returns the previous mask as a Lua number.

If $cmask$ is not specified, queries the process umask in a thread-safe manner and returns the mask as a Lua number.

\subsubsection[\fn{uname}]{\fn{uname([$\ldots$])}}

If no arguments are given, on success returns a table with the following fields

\begin{description}
\item[.sysname] \hfill \\
Name of the current system as a string.
\item[.nodename] \hfill \\
Name of this node within an implementation-defined communications network as a string.
\item[.release] \hfill \\
Release name of the operating system as a string.
\item[.version] \hfill \\
Version of the operating system as a string.
\item[.machine] \hfill \\
Hardware description of the system as a string.
\end{description}

If additional arguments are given, on success each field specified (as named above) is returned as part of the return value list.

On failure returns \nil, an error string, and an integer system error.

\subsubsection[\fn{unlink}]{\fn{unlink($path$)}}

Deletes the file entry at $path$.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{unlinkat}]{\fn{unlinkat($file$|$dir$|$fd$, $path$[, $flags$])}}

Deletes the file entry at $path$ relative to the specified open directory file descriptor, $fd$, or a FILE handle or DIR handle that wraps such a descriptor.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\subsubsection[\fn{unlockpt}]{\fn{unlockpt($file$)}}

FIXME.

\subsubsection[\fn{unsetenv}]{\fn{unsetenv($name$)}}

Deletes the environment variable $name$ from the environment table.

Returns \true on success, otherwise \false, an error string, and an integer system error.

\emph{This function is thread-safe on Solaris, NetBSD, and Linux/glibc. But see note at \fn{getenv}. Also see note at \fn{setenv}. In general \fn{unsetenv} should be avoided in multi-threaded environments.}

\subsubsection[\fn{wait}]{\fn{wait([$pid$][, $options$])}}

FIXME.

\subsubsection[\fn{waitpid}]{\fn{waitpid([$pid$][, $options$])}}

FIXME.

\subsubsection[\fn{write}]{\fn{write($file$, $data$)}}

Writes $data$ to $file$. $file$ may be either a FILE handle or integer file descriptor.

Returns an integer representing the number of bytes written (which may be less than \texttt{\#data}) on success, \otherwise{\nil}.

\end{Module}

\begin{Module}{unix.dir}

The \module{unix.dir} module implements the prototype for DIR handles, as returned by \fn{unix.opendir}.

\subsubsection[\fn{dir:files}]{\fn{dir:files([$field$ $\ldots$])}}

Returns an iterator over \fn{unix.readdir($\ldots$)}.

\subsubsection[\fn{dir:read}]{\fn{dir:read([$field$ $\ldots$])}}

Identical to \fn{unix.readdir}.

\subsubsection[\fn{dir:rewind}]{\fn{dir:rewind()}}

Identical to \fn{unix.rewinddir}.

\subsubsection[\fn{dir:close}]{\fn{dir:close()}}

Identical to \fn{unix.closedir}.

\end{Module}

\chapter{Appendix}

\section[\fn{setrecvaddr}]{\fn{setrecvaddr}: Prepare socket for recvfromto}

\label{setrecvaddr}

A routine to set the socket options necessary for \fn{recvfromto}. Options should be set before binding the socket to an address as on some platforms (e.g. FreeBSD) any packets received beforehand will not be tagged with the destination address.

\begin{example}{lua}
local unix = require"unix"

local function setrecvaddr(fd, family)
  local type, level

  if family == unix.AF_INET6 then
    level = unix.IPPROTO_IPV6
    type = unix.IPV6_RECVPKTINFO or unix.IPV6_PKTINFO
  elseif family == unix.AF_INET
    level = unix.IPPROTO_IP
    type = unix.IP_RECVDSTADDR or unix.IP_PKTINFO
  end

  if level and type then
    return unix.setsockopt(fd, level, type, true)
  else
    local errno = unix.EAFNOSUPPORT
    return false, unix.strerror(errno), errno
  end
end
\end{example}

\clearpage

\section[\fn{strevents}]{\fn{strevents}: Stringify poll events}

\label{setevents}

A routine to translate an integer bitfield of poll events to a string of constant names.

\begin{example}{lua}
local unix = require"unix"

local function strconst(c, patt)
  for k,v in pairs(unix) do
    if c == v and type(k) == "string" and k:match(patt) then
      return k
    end
  end
end

local function strevent(event)
  return strconst(event, "^POLL")
end

local function strevents(events)
  local t = {}
  for i=0,30 do
    if events % 2 == 1 then
      t[#t + 1] = strevent(2^i)
      events = events - 1
    end
    events = events / 2
  end
  return #t > 0 and table.concat(t, ", ") or nil
end
\end{example}

\clearpage

%\chapter{Examples}
%
%These examples and others are made available under examples/ in the source tree.
%
%\section{Self-Signed Certificate}
%
%\begin{example}{lua}
%
%\end{example}
%
%
%\clearpage
%
%\section{Signature Generation \& Verification}
%
%\begin{example}{lua}
%\end{example}
%


\appendix
\printindex

\end{document}
